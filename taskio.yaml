AWSTemplateFormatVersion: "2010-09-09"
Description: |
  Plantilla para gestionar la infraestructura de Taskio,
  incluyendo DynamoDB, Lambdas, API Gateway y Cognito Authorizer.


Parameters:

  EnvName:
    Type: String
    Default: dev
    Description: "Nombre del entorno (dev, staging, prod)"
  
  ExistingUserPoolArn:
    Type: String
    Default: "arn:aws:cognito-idp:eu-west-1:677276115170:userpool/eu-west-1_7scp8CGFe"
    Description: "ARN del User Pool existente"



     

Resources:
  MyCognitoAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      Name: MyCognitoAuthorizer
      Type: COGNITO_USER_POOLS
      RestApiId: !Ref TaskioApiGateway
      IdentitySource: method.request.header.Authorization
      ProviderARNs:
        - !Ref ExistingUserPoolArn



  # Rol básico para la Lambda
  TaskioLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "TaskioLambdaRole-${EnvName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: "DynamoDBAccessPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Scan
                  - dynamodb:Query
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                Resource:
                  - !GetAtt JobsTable.Arn
                  - !GetAtt ApplicationsTable.Arn
                  - !GetAtt UserSkillsTable.Arn
                  - !GetAtt ActivitiesTable.Arn
                  - !GetAtt ReviewsTable.Arn


  # Tabla de DynamoDB para Jobs
  JobsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "TaskioJobsTable-${EnvName}"
      AttributeDefinitions:
        - AttributeName: "job_id"
          AttributeType: "S"
        - AttributeName: "userId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "job_id"
          KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: "UserIdIndex"
          KeySchema:
            - AttributeName: "userId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
      BillingMode: PAY_PER_REQUEST


  UserSkillsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "TaskioUserSkillsTable-${EnvName}"
      AttributeDefinitions:
        - AttributeName: "userId"
          AttributeType: "S"
        - AttributeName: "skillName"
          AttributeType: "S"
        - AttributeName: "level"
          AttributeType: "N"
      KeySchema:
        - AttributeName: "userId"
          KeyType: "HASH"
        - AttributeName: "skillName"
          KeyType: "RANGE"
      GlobalSecondaryIndexes:
        - IndexName: "SkillNameIndex"
          KeySchema:
            - AttributeName: "skillName"
              KeyType: "HASH"
            - AttributeName: "level"
              KeyType: "RANGE"
          Projection:
            ProjectionType: "ALL"
      BillingMode: PAY_PER_REQUEST


  # Tabla de DynamoDB para Applications
  ApplicationsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "TaskioApplicationsTable-${EnvName}"
      AttributeDefinitions:
        - AttributeName: "application_id"
          AttributeType: "S"
        - AttributeName: "jobId"
          AttributeType: "S"
        - AttributeName: "userId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "application_id"
          KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: "JobIdIndex"
          KeySchema:
            - AttributeName: "jobId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
        - IndexName: "UserIdIndex"
          KeySchema:
            - AttributeName: "userId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
      BillingMode: PAY_PER_REQUEST

  # Tabla de DynamoDB para Applications
  ActivitiesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "TaskioActivitiesTable-${EnvName}"
      AttributeDefinitions:
        - AttributeName: "activity_id"
          AttributeType: "S"
        - AttributeName: "userId"
          AttributeType: "S"
        - AttributeName: "jobId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "activity_id"
          KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: "UserIdIndex"
          KeySchema:
            - AttributeName: "userId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
        - IndexName: "JobIdIndex"
          KeySchema:
            - AttributeName: "jobId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
      BillingMode: PAY_PER_REQUEST

  # Tabla de DynamoDB para Applications
  ReviewsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "TaskioReviewsTable-${EnvName}"
      AttributeDefinitions:
        - AttributeName: "review_id"
          AttributeType: "S"
        - AttributeName: "reviewerId"
          AttributeType: "S"
        - AttributeName: "activityId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "review_id"
          KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: "RevieweeIdIndex"
          KeySchema:
            - AttributeName: "reviewerId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
        - IndexName: "ActivityIdIndex"
          KeySchema:
            - AttributeName: "activityId"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"
      BillingMode: PAY_PER_REQUEST


  # API Gateway
    
  TaskioApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "TaskioApi-${EnvName}"

  # Recurso /health
  TaskioHealthResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "health"
      

  # Recurso /jobs
  TaskioJobsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "jobs"

  
  # Recurso /skills
  TaskioSkillsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "skills"

  # Recurso /applications
  TaskioApplicationsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "applications"

  # Recurso /activities
  TaskioActivitiesResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "activities"
  
  # Recurso /reviews
  TaskioReviewsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ParentId: !GetAtt TaskioApiGateway.RootResourceId
      PathPart: "reviews"




  # Método GET /health -> Lambda
  TaskioHealthGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioHealthResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioHealthCheckLambda.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: "200"
      MethodResponses:
        - StatusCode: "200"

  # Método GET /jobs -> Lambda
  TaskioJobsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioJobsResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioJobsLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "200"

  # Método POST /jobs -> Lambda
  TaskioJobsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioJobsResource
      HttpMethod: "POST"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioJobsLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "201"


  # Metodos OPTIONS para CORS
  TaskioJobsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioJobsResource
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      Integration:
        Type: "MOCK"
        IntegrationHttpMethod: "POST"
        RequestTemplates:
          application/json: '{"statusCode": 200}' # Respuesta de MOCK
        IntegrationResponses:
          - StatusCode: "200"
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: "200"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # Método Get /skills -> Lambda
  TaskioSkillsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioSkillsResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioSkillsLambda.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: "200"
      MethodResponses:
        - StatusCode: "200"


  # Método Post /skills -> Lambda
  TaskioSkillsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioSkillsResource
      HttpMethod: "POST"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioSkillsLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "201"      


  # Método Get /applications -> Lambda
  TaskioApplicationsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioApplicationsResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioApplicationsLambda.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: "200"
      MethodResponses:
        - StatusCode: "200"

  # Método Post /applications -> Lambda
  TaskioApplicationsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioApplicationsResource
      HttpMethod: "POST"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioApplicationsLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "201"

  # Método Get /activities -> Lambda
  TaskioActivitiesGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioActivitiesResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioActivitiesLambda.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: "200"
      MethodResponses:
        - StatusCode: "200"

  # Método Post /activities -> Lambda
  TaskioActivitiesPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioActivitiesResource
      HttpMethod: "POST"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioActivitiesLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "201"

  # Método Get /reviews -> Lambda
  TaskioReviewsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioReviewsResource
      HttpMethod: "GET"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioReviewsLambda.Arn}/invocations"
        IntegrationResponses:
          - StatusCode: "200"
      MethodResponses:
        - StatusCode: "200"

  # Método Post /reviews -> Lambda
  TaskioReviewsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TaskioApiGateway
      ResourceId: !Ref TaskioReviewsResource
      HttpMethod: "POST"
      AuthorizationType: "COGNITO_USER_POOLS"
      AuthorizerId: !Ref MyCognitoAuthorizer
      Integration:
        Type: "AWS_PROXY"
        IntegrationHttpMethod: "POST"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TaskioReviewsLambda.Arn}/invocations"
      MethodResponses:
        - StatusCode: "201"




  # Lambda para HealthCheck
  TaskioHealthCheckLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioHealthCheckLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Code:
        ZipFile: |
          def handler(event, context):
              return {
                  "statusCode": 200,
                  "body": "OK, healthy!"
              }

  # Lambda para Jobs (GET y POST)
  TaskioJobsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioJobsLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Environment:
        Variables:
          JOBS_TABLE_NAME: !Ref JobsTable
          APPLICATIONS_TABLE_NAME: !Ref ApplicationsTable
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          jobs_table = dynamodb.Table(os.environ['JOBS_TABLE_NAME'])

          def handler(event, context):
              http_method = event['httpMethod']
              
              if http_method == 'GET':
                  return get_jobs(event)
              elif http_method == 'POST':
                  return create_job(event)
              else:
                  return {
                      "statusCode": 405,
                      "body": json.dumps({"message": "Method Not Allowed"})
                  }

          def get_jobs(event):
              try:
                  response = jobs_table.scan()
                  jobs = response.get('Items', [])
                  
                  # Manejar paginación
                  while 'LastEvaluatedKey' in response:
                      response = jobs_table.scan(ExclusiveStartKey=response['LastEvaluatedKey'])
                      jobs.extend(response.get('Items', []))
                  
                  return {
                      "statusCode": 200,
                      "body": json.dumps(jobs, default=str)  # Evita errores con Decimal
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }

          def create_job(event):
              try:
                  body = json.loads(event['body'])
                  
                  # Validar los campos necesarios
                  required_fields = ["job_id", "title", "shortDescription", "longDescription", "category", "location", "rate", "duration", "createdAt", "postedBy"]
                  for field in required_fields:
                      if field not in body:
                          return {
                              "statusCode": 400,
                              "body": json.dumps({"message": f"Missing field: {field}"})
                          }
                  
                  # Crear el objeto Job
                  job = {
                      "job_id": body['job_id'],
                      "title": body['title'],
                      "shortDescription": body['shortDescription'],
                      "longDescription": body['longDescription'],
                      "category": body['category'],
                      "location": body['location'],
                      "rate": body['rate'],
                      "duration": body['duration'],
                      "createdAt": body['createdAt'],
                      "rating": 0,
                      "ratingCount": 0,
                      "postedBy": body['postedBy'],
                      "applicants": [],
                      "status": "open"
                  }
                  
                  # Insertar el Job en la tabla
                  jobs_table.put_item(Item=job)
                  
                  return {
                      "statusCode": 201,
                      "body": json.dumps({"message": "Job creado exitosamente.", "job": job})
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }



  # Lambda para Skills
  TaskioSkillsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioSkillsLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Environment:
        Variables:
          SKILLS_TABLE_NAME: !Ref UserSkillsTable
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          skills_table = dynamodb.Table(os.environ['SKILLS_TABLE_NAME'])

          def handler(event, context):
              http_method = event.get('httpMethod', '')

              if http_method == 'GET':
                  return get_skills(event)
              elif http_method == 'POST':
                  return create_skill(event)
              else:
                  return {
                      "statusCode": 405,
                      "body": json.dumps({"message": "Method Not Allowed"})
                  }

          def get_skills(event):
              try:
                  response = skills_table.scan()
                  skills = response.get('Items', [])

                  # Manejo de paginación
                  while 'LastEvaluatedKey' in response:
                      response = skills_table.scan(ExclusiveStartKey=response['LastEvaluatedKey'])
                      skills.extend(response.get('Items', []))

                  return {
                      "statusCode": 200,
                      "body": json.dumps(skills, default=str)  # Evita errores con Decimal
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }

          def create_skill(event):
              try:
                  body = json.loads(event['body'])
                  
                  # Validar campos necesarios
                  required_fields = ["userId", "skillName", "level"]
                  for f in required_fields:
                      if f not in body:
                          return {
                              "statusCode": 400,
                              "body": json.dumps({"message": f"Missing field: {f}"})
                          }
                  
                  # Crear el item skill
                  skill_item = {
                      "userId": body["userId"],
                      "skillName": body["skillName"],
                      "level": int(body["level"]),
                  }
                  # Insertar el skill en la tabla
                  skills_table.put_item(Item=skill_item)

                  return {
                      "statusCode": 201,
                      "body": json.dumps({"message": "Skill creado exitosamente.", "skill": skill_item})
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }


  # Lambda para Applications
  TaskioApplicationsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioApplicationsLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Environment:
        Variables:
          APPLICATIONS_TABLE_NAME: !Ref ApplicationsTable
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          applications_table = dynamodb.Table(os.environ['APPLICATIONS_TABLE_NAME'])

          def handler(event, context):
            http_method = event["httpMethod"]
            if http_method == "GET":
                  return get_applications(event)
              elif http_method == "POST":
                  return create_application(event)
              else:
                  return {
                      "statusCode": 405,
                      "body": json.dumps({"message": "Method Not Allowed"})
                  }

            def get_applications(event):
                try:
                    # Leer query params (si quieres filtrar por userId o jobId)
                    params = event.get("queryStringParameters", {})
                    user_id = params.get("userId")
                    job_id = params.get("jobId")

                    if user_id:
                        # Query GSI userId
                        response = applications_table.query(
                            IndexName="UserIdIndex",
                            KeyConditionExpression="userId = :uid",
                            ExpressionAttributeValues={":uid": user_id}
                        )
                    elif job_id:
                        # Query GSI jobId
                        response = applications_table.query(
                            IndexName="JobIdIndex",
                            KeyConditionExpression="jobId = :jid",
                            ExpressionAttributeValues={":jid": job_id}
                        )
                    else:
                        # Si no hay filtro, scan
                        response = applications_table.scan()

                    items = response.get("Items", [])
                    return {
                        "statusCode": 200,
                        "body": json.dumps(items)
                    }
                except Exception as e:
                    return {
                        "statusCode": 500,
                        "body": json.dumps({"message": str(e)})
                    }

            def create_application(event):
                try:
                    body = json.loads(event["body"])
                    required_fields = ["application_id", "jobId", "userId", "status"]
                    for f in required_fields:
                        if f not in body:
                            return {
                                "statusCode": 400,
                                "body": json.dumps({"message": f"Missing field: {f}"})
                            }

                    app_item = {
                        "application_id": body["application_id"],
                        "jobId": body["jobId"],
                        "userId": body["userId"],
                        "status": body["status"],
                        "createdAt": body.get("createdAt", "2025-02-01T10:00:00Z"),
                        "message": body.get("message", "")
                    }
                    applications_table.put_item(Item=app_item)

                    return {
                        "statusCode": 201,
                        "body": json.dumps({"message": "Application created", "application": app_item})
                    }
                except Exception as e:
                    return {
                        "statusCode": 500,
                        "body": json.dumps({"message": str(e)})
                    }
              
              


  # Lambda para Activities
  TaskioActivitiesLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioActivitiesLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Environment:
        Variables:
          ACTIVITIES_TABLE_NAME: !Ref ActivitiesTable
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          activities_table = dynamodb.Table(os.environ['ACTIVITIES_TABLE_NAME'])

          def handler(event, context):
              http_method = event.get('httpMethod', '')

              if http_method == 'GET':
                  return get_activities(event)
              elif http_method == 'POST':
                  return create_activity(event)
              else:
                  return {
                      "statusCode": 405,
                      "body": json.dumps({"message": "Method Not Allowed"})
                  }

          def get_activities(event):
              try:
                  response = activities_table.scan()
                  activities = response.get('Items', [])
                  
                  # Manejo de paginación
                  while 'LastEvaluatedKey' in response:
                      response = activities_table.scan(ExclusiveStartKey=response['LastEvaluatedKey'])
                      activities.extend(response.get('Items', []))
                  activities["rating"] = float(activities["rating"])
                  activities["comment"] = str(activities["comment"])
                  return {
                      "statusCode": 200,
                      "body": json.dumps(activities)
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }

          def create_activity(event):
              try:
                  body = json.loads(event['body'])

                  # Ajustar fields según el UML
                  required_fields = [
                      "activity_id",    # ID único
                      "jobId", 
                      "userId",
                      "title",
                      "date",
                      "duration",
                      "payment",
                      "status",         # "in-progress", "completed", etc.
                      "createdAt"
                  ]
                  for f in required_fields:
                      if f not in body:
                          return {
                              "statusCode": 400,
                              "body": json.dumps({"message": f"Missing field: {f}"})
                          }

                  # rating y comment podrías querer como opcionales
                  # Ejemplo: si no vienen, los inicializas:
                  rating_value = body.get("rating", 0)
                  comment_value = body.get("comment", "")

                  activity_item = {
                      "activity_id": body["activity_id"],
                      "jobId": body["jobId"],
                      "userId": body["userId"],
                      "title": body["title"],
                      "date": body["date"],
                      "rating": rating_value,
                      "comment": comment_value,
                      "duration": body["duration"],
                      "payment": body["payment"],
                      "status": body["status"],
                      "createdAt": body["createdAt"]
                  }

                  activities_table.put_item(Item=activity_item)

                  return {
                      "statusCode": 201,
                      "body": json.dumps({
                          "message": "Activity creado exitosamente.",
                          "activity": activity_item
                      })
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }


# Lambda para Reviews
  TaskioReviewsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "TaskioReviewsLambda-${EnvName}"
      Handler: "lambda_function.handler"
      Runtime: "python3.9"
      Role: !GetAtt TaskioLambdaRole.Arn
      Environment:
        Variables:
          REVIEWS_TABLE_NAME: !Ref ReviewsTable
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          reviews_table = dynamodb.Table(os.environ['REVIEWS_TABLE_NAME'])

          def handler(event, context):
              http_method = event.get("httpMethod", "")

              if http_method == "GET":
                  return get_reviews(event)
              elif http_method == "POST":
                  return create_review(event)
              else:
                  return {
                      "statusCode": 405,
                      "body": json.dumps({"message": "Method Not Allowed"})
                  }

          def get_reviews(event):
              try:
                  response = reviews_table.scan()
                  reviews = response.get('Items', [])

                  # Paginación (por si hay más items)
                  while 'LastEvaluatedKey' in response:
                      response = reviews_table.scan(ExclusiveStartKey=response['LastEvaluatedKey'])
                      reviews.extend(response.get('Items', []))

                  # Convertir a JSON. default=str para evitar errores con Decimal
                  return {
                      "statusCode": 200,
                      "body": json.dumps(reviews, default=str)
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }

          def create_review(event):
              try:
                  body = json.loads(event["body"])
                  
                  # Ajustar fields según tu UML para "Review"
                  required_fields = [
                      "review_id",      # ID de la review
                      "reviewerId",     # Quién escribe la review
                      "revieweeId",     # A quién se reseña
                      "activityId",
                      "createdAt",
                      "questionRatings",  # array de {questionId, rating}
                      "finalComment"
                  ]
                  for f in required_fields:
                      if f not in body:
                          return {
                              "statusCode": 400,
                              "body": json.dumps({"message": f"Missing field: {f}"})
                          }

                  review_item = {
                      "review_id": body["review_id"],
                      "reviewerId": body["reviewerId"],
                      "revieweeId": body["revieweeId"],
                      "activityId": body["activityId"],
                      "createdAt": body["createdAt"],
                      "questionRatings": body["questionRatings"],
                      "finalComment": body["finalComment"]
                  }

                  # Insertar la review en la tabla
                  reviews_table.put_item(Item=review_item)

                  return {
                      "statusCode": 201,
                      "body": json.dumps({
                          "message": "Review creado exitosamente.",
                          "review": review_item
                      })
                  }
              except Exception as e:
                  return {
                      "statusCode": 500,
                      "body": json.dumps({"message": str(e)})
                  }




  # Permitir que API Gateway invoque las Lambdas
  PermissionTaskioHealthCheckApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioHealthCheckLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*/GET/health"

  PermissionTaskioJobsApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioJobsLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*"

  PermissionTaskioSkillsApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioSkillsLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*"


  PermissionTaskioApplicationsApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioApplicationsLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*"

  PermissionTaskioActivitiesApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioActivitiesLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*"

  PermissionTaskioReviewsApi:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt TaskioReviewsLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TaskioApiGateway}/*"

  


  # Deployment + Stage
  TaskioApiDeploymentDev:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - TaskioHealthGetMethod
      - TaskioJobsGetMethod
      - TaskioJobsPostMethod
      - TaskioJobsOptionsMethod
      - TaskioSkillsGetMethod
      - TaskioSkillsPostMethod
      - TaskioApplicationsGetMethod
      - TaskioApplicationsPostMethod
      - TaskioActivitiesGetMethod
      - TaskioActivitiesPostMethod
      - TaskioReviewsGetMethod
      - TaskioReviewsPostMethod


    Properties:
      RestApiId: !Ref TaskioApiGateway
      StageName: !Sub "${EnvName}"

Outputs:
  ApiUrl:
    Description: "URL base de la API"
    Value: !Sub "https://${TaskioApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${EnvName}"
  JobsTableName:
    Description: "Nombre de la Tabla de Jobs"
    Value: !Ref JobsTable
  ApplicationsTableName:
    Description: "Nombre de la Tabla de Applications"
    Value: !Ref ApplicationsTable
  ActivitiesTableName:
    Description: "Nombre de la Tabla de Activities"
    Value: !Ref ActivitiesTable
  ReviewsTableName:
    Description: "Nombre de la Tabla de Reviews"
    Value: !Ref ReviewsTable